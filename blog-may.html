<!DOCTYPE html>
<html>
<head>
<title>Daily Coding Blog</title>
<link href="blog.css" type="text/css" rel="stylesheet" />

</head>
<body>
    <header>
        <h1 id="top"> <a href="index.html"> My Daily Coding Blog</a></h1>
        <h2>May</h2>
    </header>

    <main>

<h3>The Odin Project Blog Post 17</h3>
    <datetime>May 5 2017</datetime>
    <br>
    <h4>Week 17 - Dealing With the Database and SQL</h4>

<p> The next lily pad in my learning process is something I’ve often overlooked but is absolutely necessary to have some understanding of for building CRUD applications: the database. It’s not one of the flashy things you want to learn because the database isn’t presented to the user at any point, and for me it always seemed like an mysterious, esoteric place that I’d never want to touch. But after this week’s lesson, the SQL language is nowhere near one of the more difficult concepts I've faced. It got trickier towards the end of the project when dealing with multiple JOINs and SELECTs, but from what I understand, we will hardly need to know things like that off the top of our heads. ActiveRecord and Google can ease the burden. Like the rest of the Rails magic we’ve been learning though, it is good to have at least a vanilla understanding of SQL so that we know what is happening and how to interact with our database.</p>

<p> The first step in a CRUD application is Create. Therefore, let’s look at creating a table in SQL. For this post, I will use a very simple example. It will be a three-column table containing information that you might see as a restaurant's inventory. If I type into my editor <code> create table Categories (CategoryID int, CategoryName varchar, Description varchar);</code>, I’m going to get three column headers.</p>

<img id="cat_head" src="images/CategoryHeader.png" />

<p>In order to fill the table, I'll use the <code>insert into</code> syntax. This is the the (U)pdate part of our CRUD app. The CategoryID will automatically be filled with an integer so I don't need to worry about that, but the CategoryName will take a string (varchar) and so will the Description. In all, my code will look something like this: </p>

<code><pre>
insert into Categories
(CategoryName, Description)
values ('Beverages', 'Soft drinks, coffeees, teas, beers, and ales')
insert into Categories
(CategoryName, Description)
values('Condiments', 'Sweet and savory sauces, relishes, spreads, and seasonings');
.
.
.
</pre></code>

<img id="categories" src="images/CategoriesTable.png" />

<p>Now that my table is filled out, we can get to the meat and potatoes of the SQL language: making queries. Right now our database has three columns and eight rows. In order to (R)ead the database, we need to select items from our table using the <code>SELECT * from Categories</code> operation. This specific line will simply return all (*) the items from our table. But we can be far more specific. For example, if we want the name and description of just produce, beverages and meat, we can type <code>SELECT CategoryName, Description FROM Categories
WHERE CategoryName IN ('Produce', 'Beverages', 'Meat/Poultry')</code> and we'll get back:</p>

        <img id="selected" src="images/SelectedItems.png" />

<p>Calls to the database will pretty much always follow the same syntax. You first tell the db you want to select something, and then you specify from what table you are making the selection. Your options are almost endless as far as what you can retrieve. I'll use solutions from the SQL Zoo tutorials to describe more complicated examples, because the Categories table just isn't large enough. </p>

<code><pre>
SELECT player, teamid,coach, gtime
  FROM goal JOIN eteam ON (teamid=id)
 WHERE gtime&lt;=10
</pre></code>

<p>One of the trickier but more useful actions SQL can perform is joining tables together and making queries from the newly compounded info. The code above uses the <code>JOIN</code> keyword to link together a table called "goal" and a table called "eteam" <code>ON</code> their matching columns. In this case the "teamid" from goal and "id" from eteam match up, so the tables fit together. The query I've made is to select the player, teamid, and gtime(game time) from goal and the coach from eteam, for every goal scored before the 10th minute. When the code is run, I will get back a four-columm table with all gtimes under 10. I could go on and on describing different examples of queries, but actually coding them is far better practice than writing or reading about them.</p>

<p>Having mentioned the C, R, and U, for the sake of continuity I feel obligated to at least mention the D in CRUD. None of the resources spent much time on deletion, and that's probably because it's almost identical to select. Let's return to the Categories table I created earlier. If I <code>DELETE from Categories WHERE CategoryID = 1</code>, the entire first row will be wiped from the database. Like querying, we can use WHERE to make conditions for deletion, and if we do not, everything from the specified table will be deleted. </p>

<p>Simple examples, but the conditions entered can make things more complex. Next week I will learn about Active Record and how that fits into the application structure.</p>

<h3>May 3-4 2017</h3>
    <ul>
        <li>Worked on and completed SQL Zoo tutorials <a href="https://github.com/ks927/Notes-and-Tutorials/tree/master/SQL/SQLZoo">GitHub</a></li>
    </ul>


 <h3>May 1-2 2017</h3>
    <ul>
        <li>Finished SQL tutorial</li>
        <li>Completed <a href="http://www.sqlcourse2.com/">Part 2</a> of SQL tutorial</li>
        <li>Began Project <a href="http://sqlzoo.net/wiki/SQL_Tutorial">SQL Zoo</a> and finished first 3 tutorials</li>
    </ul>

    </main>

    <footer>
    <a href="blog-apr.html" class="next">April posts>></a>
    </footer>
    </body>
</html>
