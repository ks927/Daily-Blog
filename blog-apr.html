<!DOCTYPE html>
<html>
<head>
<title>Daily Coding Blog</title>
<link href="blog.css" type="text/css" rel="stylesheet" />

</head>
<body>
    <header>
        <h1 id="top"> <a href="index.html"> My Daily Coding Blog</a></h1>
        <h2>April</h2>
    </header>

<main>

<h3>April 18 2017</h3>
    <ul>
        <li>Began sample app project - worked on testing suite in Rails</li>
        <li>Began work on portfolio site <a href="https://kyletsheehan.wordpress.com/">kyletsheehan.wordpress.com</a></li>
        <li><strong>Attended first Philly.rb meetup</strong></li>
    </ul>

<h3>April 17 2017</h3>
    <ul>
        <li>Updated weekly goals page</li>
        <li>Read TOP's <a href="http://www.theodinproject.com/courses/ruby-on-rails/lessons/deployment?ref=lc-pb">Deployment</a> page</li>
        <li>Completed 1/2 of Project: Web Refresher - RestClient</li>
    </ul>
    <code><pre>
    r = RestClient.get('https://www.bing.com/', params: {q: 'coding jobs'})
    r.code
    r.headers
    r.body
    </pre></code>

<h3>The Odin Project Blog Post 14</h3>
    <datetime>April 14 2017</datetime>
    <br>
    <h4>Week 14 - Beginning Rails and MVC</h4>

<p> While I could spend this post writing about something I have a stronger grasp of, like the Hangman project I completed using Sinatra earlier in the week, there are two reasons I’m not going to do that. First, though that program vastly out-scopes what I wrote about last week, I would more or less be rehashing the main points of routes and views in the Sinatra framework. Second, one of the main reasons for these posts is so that I can further my understanding of difficult concepts via writing. That is why I’m choosing to write about the second “project” I finished this week. It was the second Rails tutorial TOP has led us through. However, this one actually felt like it was laying an educational foundation to build upon. From the very limited exposure I’ve had to the magic of Rails so far, I will attempt to explain what I picked up. </p>

<p> Something that always intimidated me about Rails was the amount of files and folders that come along with a single application. I thought to myself I’d never be able to learn this because there’s just too much stuff and I’d never be able to keep it all straight. Alas, the file directory of the app is split up deliberately to be very well organized. Until now I had no idea the rhyme or reason, but TOP and Michael Hartl’s tutorials do a thorough job of breaking it down and explaining it all. Rails apps follow a Model View Controller structure. Every application has a models, a views, and a controllers directory - each with a specific job. Once you understand the purpose of MVC, the mist surrounding Rails starts to clear. MVC is not only integral to understanding Rails but web development as a whole, and I will attempt to explain it here: </p>

<img src="images/mvc-rails.png" />

    <p> Obviously, it all starts at the user’s computer, when a request is made from the browser. Ignoring the server element here, this information gets parsed by the controller which asks the model for any data or other information it needs. The model is the one that connects to the database, stores or <strong>validates</strong> data, and does the heavy lifting. The info then gets returned to the controller which gives it to the view; where it gets turned into something to be displayed back to the user. The view is where you find the html and erb. It has no idea what to display until the controller fills it in. Once this has been done, it is finally returned through the controller as a web page back to the browser. Simple! So how does this apply to what I built this week? </p>

    <code><pre>toy_app/app/controllers/user_controller.rb
    class UsersController &lt; ApplicationController
  before_action :set_user, only: [:show, :edit, :update, :destroy]

  # GET /users
  # GET /users.json
  def index
    @users = User.all
  end

  # GET /users/1
  # GET /users/1.json
  def show
  end

  # GET /users/new
  def new
    @user = User.new
  end

  # GET /users/1/edit
  def edit
  end

  # POST /users
  # POST /users.json
  def create
    @user = User.new(user_params)

    respond_to do |format|
      if @user.save
        format.html { redirect_to @user, notice: 'User was successfully created.' }
        format.json { render :show, status: :created, location: @user }
      else
        format.html { render :new }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end

  # PATCH/PUT /users/1
  # PATCH/PUT /users/1.json
  def update
    respond_to do |format|
      if @user.update(user_params)
        format.html { redirect_to @user, notice: 'User was successfully updated.' }
        format.json { render :show, status: :ok, location: @user }
      else
        format.html { render :edit }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /users/1
  # DELETE /users/1.json
  def destroy
    @user.destroy
    respond_to do |format|
      format.html { redirect_to users_url, notice: 'User was successfully destroyed.' }
      format.json { head :no_content }
    end
  end

  private
    # Use callbacks to share common setup or constraints between actions.
    def set_user
      @user = User.find(params[:id])
    end

    # Never trust parameters from the scary internet, only allow the white list through.
    def user_params
      params.require(:user).permit(:name, :email)
    end
end
    </pre></code>

    <p>This is my controller for the toy app I created. It contains the most code by far out of the models/views/controllers files. This makes sense because it is the core of the application, and needs to handle requests from the client. In this case, we can see the typical CRUD methods (create, edit, update, destroy) for a user page (think create/edit/delete user). Once one of these methods is invoked, the controller checks with the model for anything it needs.</p>

    <code><pre>toy_app/app/models/user.rb
    class User &lt; ApplicationRecord
    has_many :microposts
    validates :name, presence: true
    validates :email, presence:true
end
    </pre></code>

    <p>Here we have just 5 lines of code that make up the user model of my application. It allows each user to have multiple posts and requires that a user have a name and an email in order to be validated. If what the client entered in his/her browser meets the requirements here, a new user is added to the database. When the model is done with its job, the data can be sent to the view to be made ready for the screen.</p>

    <code><pre> toy_app/views/user/index.html.erb
    <xmp>
    <p id="notice"><%= notice %></p>

<h1>Users</h1>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Email</th>
      <th colspan="3"></th>
    </tr>
  </thead>

  <tbody>
    <% @users.each do |user| %>
      <tr>
        <td><%= user.name %></td>
        <td><%= user.email %></td>
        <td><%= link_to 'Show', user %></td>
        <td><%= link_to 'Edit', edit_user_path(user) %></td>
        <td><%= link_to 'Destroy', user, method: :delete, data: { confirm: 'Are you sure?' } %></td>
      </tr>
    <% end %>
  </tbody>
</table>

<br>

<%= link_to 'New User', new_user_path %>
</xmp>
    </pre></code>

    <p>Without getting bogged down on the details of the code within this file, it is just important to know that whatever method the client invoked in the controller was validated by the model and will now be transmitted as html via erb in the view. If we choose to create a user, the model validates the name and email, and the view shows us a new user. If we choose to destroy a user, the controller goes to the model which finds the user in the database. The view asks if we are sure. If we say yes, the controller tells the model to delete that user from the database, and the view shows us a page without that user.</p>


<h3>April 13 2017</h3>
    <ul>
        <li>Completed Toy App Hartl tutorial <a href="https://ancient-scrubland-81329.herokuapp.com/">Heroku</a> <a href="https://github.com/ks927/toy_app">GitHub</a></li>
        <li>Read the <a href="http://www.theodinproject.com/courses/ruby-on-rails/lessons/a-railsy-web-refresher?ref=lc-pb">a Railsy Web Refresher</a> section on TOP</li>
        <li>Read the <a href="http://www.theodinproject.com/courses/ruby-on-rails/lessons/deployment?ref=lnav">Deployment</a> section</li>
    </ul>

<h3>April 11-12 2017</h3>
    <ul>
        <li>Worked on and completed hangman Sinatra app and deployed it to the web <a href="https://glacial-retreat-36955.herokuapp.com/">Heroku</a> <a href="https://github.com/ks927/sinatra_hangman">GitHub</a></li>
    </ul>

<h3>The Odin Project Blog Post 13</h3>
    <datetime>April 10 2017</datetime>
    <br>
    <h4>Week 13 - Sinatra</h4>

<p> One of the things I remember from the brief look at Ruby on Rails I got in the Web Development 101 section of TOP was how much of the app is created for you when you simply type <code> rails generate</code> in the terminal. Because of how much of the “dirty work” is taken out of your hands, Rails can be perceived as having a magical quality to it which may lead to a fundamental misunderstanding of what is happening under the hood. To avoid such misconception, TOP first introduces us to Sinatra. Sinatra is a lightweight Ruby framework that doesn’t put together the complex file structure of a web application for you. Learning how to set up <em>routes</em> and connect them with <em>views</em> on our own sort of demystifies the magic of Rails, and in theory, should reduce the learning curve. </p>

<p>This isn’t to say that Sinatra in itself is nothing but a stepping stone. Though it is relatively simple, in that there isn’t a whole to it, there are some cool things TOP had us do with it right off the bat. Before tossing us into the deep end, we were to follow a tutorial from <a href=“http://tutorials.jumpstartlab.com/projects/web_guesser.html>Jumpstart Labs</a> to create a pretty simple random number guesser game. Using the concepts from this tutorial, we then were asked to convert a couple of old projects into Sinatra applications - the first being the caesar cipher function. </p>

    <code><pre> /caesar_cipher/caesar_cipher.rb
    def caesar_cipher(string, num)
    @cipher = ""

    string.each_char do |ch|
        ch = ch.ord
        if ch.between?(97, 122)  || ch.between?(65, 90)
            ch += (num % 26)
        elsif ch > 122 || ch.between?(90, 97)
            ch -= (num % 26)
        end
        ch = ch.chr
        @cipher << ch
    end
    @cipher

end

get '/' do
    string = params["string"] || ""
    num = params["num"].to_i
    @cipher = caesar_cipher(string, num)
    erb :index, :locals => { :cipher => @cipher }
end
</pre></code>

<p>The portion of the code to focus on here is the get block at the bottom. This is known as the <em>route</em>. When nothing is specified after the '/', it automatically looks for the <em>views</em> folder in the same directory. The line starting with erb tells the block to look for the file named 'index' and then names what variable(s) are used from this file in that index file. In this particular case, I only use the @cipher variable in my index.erb file. </p>

<code><pre> /caeser_cipher/views/index.erb
<xmp>
<html>
<head>
    <link rel="stylesheet" href="styles.css" />
</head>
    <body>
        <form>
            <h1>This is the Caesar Cipher</h1>
            <p>Type a string you'd like to cipher:</p>
            <input type="text" name="string" />
            <p>Type how many letters you'd like it shifted:</p>
            <input type="text" name="num" />
            <br>
            <input type="submit" value="cipher!" />
            <p>Your ciphered string: <%= @cipher %></p>
        </form>
    </body>
</html></xmp></pre></code>

<p>Why does this look like an html file but it's labeled .erb? .erb stands for embedded Ruby, and essentialy means exactly that. It has Ruby from the get block in the <em>route</em> embedded within it. Likewise, the .rb file uses the user input taken from the text inputs here. What gets entered here becomes the parameters of the web address. Back in the get block, they're accessed via params["string"] and params["num"] because those are the names of the inputs. The params become the caeser cipher's parameters, and the @cipher decrypted variable gets returned to the .erb file.</p>

<p>This is a simple example because it is one method with one variable. I am currently working on converting my Hangman command line game, which so far has been a much tougher challenge.</p>

<h3>April 6 2017</h3>
    <ul>
        <li>Worked on converting Hangman game to Sinatra app</li>
    </ul>

<h3>April 5 2017</h3>
    <ul>
        <li>Watched 3 Sinatra screencasts on <a href="https://github.com/ga-wdi-lessons/sinatra-walkthrough">this site</a></li>
        <li>completed caesar_cipher Sinatra app</li>
    </ul>

<h3>April 4 2017</h3>
    <ul>
        <li>Completed Web Guesser App <a href="https://github.com/ks927/Sinatra">GitHub</a></li>
        <img src="images/web_guess.png" />
    </ul>

<h3>April 3 2017</h3>
    <ul>
        <li>Updated weekly goals</li>
        <li>Worked on Sinatra web guesser app</li>
    </ul>

    </main>

    <footer>
    <a href="blog-mar.html" class="next">March posts>></a>
    </footer>

    </body>
</html>
